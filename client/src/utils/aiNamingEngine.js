// AI-Powered Startup Naming Engine\n// Sophisticated algorithms for intelligent name generation\n\nclass AINameGenerator {\n  constructor() {\n    this.industryPatterns = {\n      tech: {\n        prefixes: ['Tech', 'Data', 'Cloud', 'Cyber', 'Digital', 'Smart', 'Auto', 'Quantum', 'Neural', 'Micro'],\n        suffixes: ['Flow', 'Sync', 'Hub', 'Lab', 'Works', 'Pro', 'Core', 'Forge', 'Vault', 'Stream'],\n        concepts: ['innovation', 'solution', 'platform', 'system', 'network', 'intelligence', 'automation'],\n        brandableWords: ['Nexus', 'Apex', 'Vertex', 'Matrix', 'Prism', 'Catalyst', 'Fusion', 'Zenith']\n      },\n      saas: {\n        prefixes: ['Work', 'Team', 'Project', 'Task', 'Flow', 'Sync', 'Connect', 'Manage', 'Track', 'Build'],\n        suffixes: ['Flow', 'Hub', 'Pro', 'Suite', 'Works', 'Space', 'Sync', 'Base', 'Core', 'Zone'],\n        concepts: ['productivity', 'collaboration', 'efficiency', 'workflow', 'management', 'automation'],\n        brandableWords: ['Asana', 'Slack', 'Notion', 'Figma', 'Zoom', 'Stripe', 'Shopify', 'Zendesk']\n      },\n      fintech: {\n        prefixes: ['Pay', 'Finance', 'Money', 'Capital', 'Wealth', 'Credit', 'Bank', 'Trade', 'Invest', 'Secure'],\n        suffixes: ['Pay', 'Wallet', 'Bank', 'Capital', 'Finance', 'Secure', 'Trust', 'Guard', 'Shield', 'Vault'],\n        concepts: ['security', 'trust', 'growth', 'investment', 'payment', 'banking', 'wealth'],\n        brandableWords: ['Stripe', 'Square', 'Robinhood', 'Coinbase', 'Venmo', 'Klarna', 'Affirm', 'Plaid']\n      },\n      healthcare: {\n        prefixes: ['Health', 'Care', 'Med', 'Vital', 'Life', 'Wellness', 'Cure', 'Heal', 'Bio', 'Therapy'],\n        suffixes: ['Care', 'Health', 'Med', 'Life', 'Vital', 'Wellness', 'Cure', 'Heal', 'Bio', 'Flow'],\n        concepts: ['healing', 'wellness', 'care', 'health', 'life', 'vitality', 'recovery', 'prevention'],\n        brandableWords: ['Teladoc', 'Veracyte', 'Moderna', 'Illumina', 'Guardant', 'Tempus', 'Flatiron']\n      },\n      ai: {\n        prefixes: ['AI', 'Neural', 'Deep', 'Smart', 'Auto', 'Cognitive', 'Intelligent', 'Machine', 'Robo', 'Synth'],\n        suffixes: ['AI', 'Mind', 'Star', 'Intelligence', 'Learning', 'Vision', 'Logic', 'Sense', 'Think', 'Cognition'],\n        concepts: ['intelligence', 'learning', 'automation', 'cognition', 'reasoning', 'perception', 'understanding'],\n        brandableWords: ['OpenAI', 'DeepMind', 'Anthropic', 'Cohere', 'Stability', 'Hugging', 'Replicate']\n      }\n    };\n\n    this.namingTechniques = [\n      'compound',\n      'metaphorical',\n      'invented',\n      'descriptive',\n      'abstract',\n      'portmanteau',\n      'acronym',\n      'brandable'\n    ];\n\n    this.phonemePatterns = {\n      strong: ['tech', 'force', 'power', 'max', 'pro', 'ultra', 'mega', 'super'],\n      smooth: ['flow', 'stream', 'wave', 'glide', 'silk', 'smooth', 'ease', 'grace'],\n      sharp: ['edge', 'point', 'sharp', 'cut', 'blade', 'spike', 'peak', 'apex'],\n      soft: ['cloud', 'soft', 'gentle', 'calm', 'peace', 'zen', 'harmony', 'balance']\n    };\n  }\n\n  // Main AI naming function\n  generateNames(input) {\n    const { industry, keywords, style, targetAudience, brandPersonality } = input;\n    const names = [];\n\n    // Generate names using different AI techniques\n    names.push(...this.generateCompoundNames(industry, keywords));\n    names.push(...this.generateMetaphoricalNames(industry, keywords, brandPersonality));\n    names.push(...this.generateInventedNames(industry, keywords));\n    names.push(...this.generatePortmanteauNames(keywords));\n    names.push(...this.generateBrandableNames(industry, brandPersonality));\n    names.push(...this.generateAbstractNames(industry, style));\n\n    // Apply AI scoring and filtering\n    const scoredNames = names.map(name => ({\n      name,\n      ...this.calculateBrandabilityScore(name, industry, targetAudience)\n    }));\n\n    // Filter and sort by AI quality score\n    return scoredNames\n      .filter(item => item.overallScore >= 7.0)\n      .sort((a, b) => b.overallScore - a.overallScore)\n      .slice(0, 50)\n      .map(item => ({\n        name: item.name,\n        score: item.overallScore,\n        memorability: item.memorability,\n        pronunciation: item.pronunciation,\n        uniqueness: item.uniqueness,\n        brandability: item.brandability,\n        description: this.generateDescription(item.name, industry),\n        reasoning: this.generateReasoning(item.name, industry, item)\n      }));\n  }\n\n  // Compound name generation (e.g., PayPal, Facebook)\n  generateCompoundNames(industry, keywords) {\n    const names = [];\n    const patterns = this.industryPatterns[industry] || this.industryPatterns.tech;\n    \n    // Keyword + Industry suffix\n    keywords.forEach(keyword => {\n      patterns.suffixes.forEach(suffix => {\n        if (keyword.toLowerCase() !== suffix.toLowerCase()) {\n          names.push(this.capitalizeFirst(keyword) + suffix);\n        }\n      });\n    });\n\n    // Industry prefix + Keyword\n    patterns.prefixes.forEach(prefix => {\n      keywords.forEach(keyword => {\n        if (prefix.toLowerCase() !== keyword.toLowerCase()) {\n          names.push(prefix + this.capitalizeFirst(keyword));\n        }\n      });\n    });\n\n    // Keyword combinations\n    for (let i = 0; i < keywords.length; i++) {\n      for (let j = i + 1; j < keywords.length; j++) {\n        names.push(this.capitalizeFirst(keywords[i]) + this.capitalizeFirst(keywords[j]));\n        names.push(this.capitalizeFirst(keywords[j]) + this.capitalizeFirst(keywords[i]));\n      }\n    }\n\n    return names;\n  }\n\n  // Metaphorical name generation (e.g., Amazon, Oracle)\n  generateMetaphoricalNames(industry, keywords, personality) {\n    const metaphors = {\n      power: ['Titan', 'Atlas', 'Zeus', 'Thor', 'Phoenix', 'Dragon', 'Eagle', 'Lion'],\n      growth: ['Sequoia', 'Bamboo', 'Vine', 'Bloom', 'Sprout', 'Flourish', 'Thrive', 'Evolve'],\n      speed: ['Lightning', 'Bolt', 'Flash', 'Rocket', 'Jet', 'Swift', 'Rapid', 'Velocity'],\n      precision: ['Laser', 'Arrow', 'Dart', 'Needle', 'Focus', 'Target', 'Aim', 'Precision'],\n      innovation: ['Pioneer', 'Frontier', 'Horizon', 'Discovery', 'Breakthrough', 'Revolution'],\n      connection: ['Bridge', 'Link', 'Network', 'Web', 'Chain', 'Bond', 'Unite', 'Connect']\n    };\n\n    const names = [];\n    const personalityMetaphors = metaphors[personality] || metaphors.innovation;\n    \n    personalityMetaphors.forEach(metaphor => {\n      names.push(metaphor);\n      keywords.forEach(keyword => {\n        names.push(metaphor + this.capitalizeFirst(keyword));\n        names.push(this.capitalizeFirst(keyword) + metaphor);\n      });\n    });\n\n    return names;\n  }\n\n  // Invented name generation (e.g., Google, Spotify)\n  generateInventedNames(industry, keywords) {\n    const names = [];\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    \n    // Generate phonetically pleasing combinations\n    keywords.forEach(keyword => {\n      const root = keyword.substring(0, Math.min(4, keyword.length));\n      \n      // Add pleasing suffixes\n      ['ly', 'fy', 'io', 'ax', 'ex', 'ix', 'ox', 'ux'].forEach(suffix => {\n        names.push(this.capitalizeFirst(root + suffix));\n      });\n      \n      // Vowel manipulation\n      vowels.forEach(vowel => {\n        names.push(this.capitalizeFirst(root + vowel + 'x'));\n        names.push(this.capitalizeFirst(root + vowel + 'z'));\n      });\n    });\n\n    // Generate completely new combinations\n    for (let i = 0; i < 10; i++) {\n      const length = 5 + Math.floor(Math.random() * 3);\n      let name = '';\n      \n      for (let j = 0; j < length; j++) {\n        if (j % 2 === 0) {\n          name += consonants[Math.floor(Math.random() * consonants.length)];\n        } else {\n          name += vowels[Math.floor(Math.random() * vowels.length)];\n        }\n      }\n      \n      names.push(this.capitalizeFirst(name));\n    }\n\n    return names;\n  }\n\n  // Portmanteau generation (e.g., Microsoft = Micro + Software)\n  generatePortmanteauNames(keywords) {\n    const names = [];\n    \n    for (let i = 0; i < keywords.length; i++) {\n      for (let j = i + 1; j < keywords.length; j++) {\n        const word1 = keywords[i];\n        const word2 = keywords[j];\n        \n        // Take first part of word1 + last part of word2\n        const split1 = Math.floor(word1.length * 0.6);\n        const split2 = Math.floor(word2.length * 0.4);\n        \n        names.push(this.capitalizeFirst(word1.substring(0, split1) + word2.substring(split2)));\n        names.push(this.capitalizeFirst(word2.substring(0, split1) + word1.substring(split2)));\n      }\n    }\n\n    return names;\n  }\n\n  // Brandable name generation\n  generateBrandableNames(industry, personality) {\n    const patterns = this.industryPatterns[industry] || this.industryPatterns.tech;\n    const names = [];\n    \n    // Use successful patterns from the industry\n    patterns.brandableWords.forEach(word => {\n      names.push(word);\n      \n      // Create variations\n      ['Pro', 'Hub', 'Lab', 'Works', 'Core'].forEach(suffix => {\n        names.push(word + suffix);\n      });\n    });\n\n    return names;\n  }\n\n  // Abstract name generation\n  generateAbstractNames(industry, style) {\n    const names = [];\n    const patterns = this.industryPatterns[industry] || this.industryPatterns.tech;\n    \n    // Generate abstract but meaningful combinations\n    patterns.concepts.forEach(concept => {\n      const variations = this.generateConceptVariations(concept);\n      names.push(...variations);\n    });\n\n    return names;\n  }\n\n  // Generate variations of a concept\n  generateConceptVariations(concept) {\n    const variations = [];\n    const prefixes = ['', 'Pro', 'Ultra', 'Super', 'Meta', 'Neo', 'Next'];\n    const suffixes = ['', 'Pro', 'Hub', 'Lab', 'Works', 'Core', 'Zone', 'Base'];\n    \n    prefixes.forEach(prefix => {\n      suffixes.forEach(suffix => {\n        if (prefix || suffix) {\n          variations.push(prefix + this.capitalizeFirst(concept) + suffix);\n        }\n      });\n    });\n\n    return variations;\n  }\n\n  // AI-powered brandability scoring\n  calculateBrandabilityScore(name, industry, targetAudience) {\n    const memorability = this.calculateMemorability(name);\n    const pronunciation = this.calculatePronunciation(name);\n    const uniqueness = this.calculateUniqueness(name, industry);\n    const brandability = this.calculateBrandability(name);\n    const marketAppeal = this.calculateMarketAppeal(name, targetAudience);\n    \n    const overallScore = (\n      memorability * 0.25 +\n      pronunciation * 0.20 +\n      uniqueness * 0.20 +\n      brandability * 0.20 +\n      marketAppeal * 0.15\n    );\n\n    return {\n      memorability: Math.round(memorability * 10) / 10,\n      pronunciation: Math.round(pronunciation * 10) / 10,\n      uniqueness: Math.round(uniqueness * 10) / 10,\n      brandability: Math.round(brandability * 10) / 10,\n      marketAppeal: Math.round(marketAppeal * 10) / 10,\n      overallScore: Math.round(overallScore * 10) / 10\n    };\n  }\n\n  // Calculate memorability score\n  calculateMemorability(name) {\n    let score = 10;\n    \n    // Length penalty\n    if (name.length > 12) score -= 2;\n    if (name.length > 15) score -= 2;\n    if (name.length < 4) score -= 1;\n    \n    // Syllable count (optimal is 2-3)\n    const syllables = this.countSyllables(name);\n    if (syllables === 2 || syllables === 3) score += 1;\n    if (syllables > 4) score -= 2;\n    \n    // Repetitive patterns\n    if (this.hasRepetitivePattern(name)) score += 1;\n    \n    // Common word recognition\n    if (this.containsCommonWords(name)) score += 0.5;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  // Calculate pronunciation score\n  calculatePronunciation(name) {\n    let score = 10;\n    \n    // Consonant clusters\n    const consonantClusters = name.match(/[bcdfghjklmnpqrstvwxyz]{3,}/gi);\n    if (consonantClusters) score -= consonantClusters.length * 2;\n    \n    // Vowel-consonant balance\n    const vowels = name.match(/[aeiou]/gi) || [];\n    const consonants = name.match(/[bcdfghjklmnpqrstvwxyz]/gi) || [];\n    const ratio = vowels.length / consonants.length;\n    if (ratio < 0.2 || ratio > 0.8) score -= 1;\n    \n    // Silent letters penalty\n    if (name.includes('gh') || name.includes('kn') || name.includes('wr')) score -= 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  // Calculate uniqueness score\n  calculateUniqueness(name, industry) {\n    let score = 10;\n    \n    // Check against common industry terms\n    const patterns = this.industryPatterns[industry] || this.industryPatterns.tech;\n    const commonTerms = [...patterns.prefixes, ...patterns.suffixes].map(t => t.toLowerCase());\n    \n    if (commonTerms.some(term => name.toLowerCase().includes(term))) {\n      score -= 2;\n    }\n    \n    // Generic terms penalty\n    const genericTerms = ['solution', 'system', 'service', 'company', 'corp', 'inc', 'llc'];\n    if (genericTerms.some(term => name.toLowerCase().includes(term))) {\n      score -= 3;\n    }\n    \n    // Invented words bonus\n    if (this.isInventedWord(name)) score += 2;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  // Calculate brandability score\n  calculateBrandability(name) {\n    let score = 8;\n    \n    // Visual appeal\n    if (this.hasVisualAppeal(name)) score += 1;\n    \n    // Emotional resonance\n    if (this.hasEmotionalResonance(name)) score += 1;\n    \n    // Scalability\n    if (this.isScalable(name)) score += 0.5;\n    \n    // Domain potential\n    if (this.hasDomainPotential(name)) score += 0.5;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  // Calculate market appeal\n  calculateMarketAppeal(name, targetAudience) {\n    let score = 8;\n    \n    // Professional appeal for B2B\n    if (targetAudience === 'b2b' && this.isProfessional(name)) score += 1;\n    \n    // Consumer appeal for B2C\n    if (targetAudience === 'b2c' && this.isConsumerFriendly(name)) score += 1;\n    \n    // Global appeal\n    if (this.hasGlobalAppeal(name)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  // Helper functions\n  capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n  }\n\n  countSyllables(word) {\n    return word.toLowerCase().replace(/[^aeiouy]/g, '').length || 1;\n  }\n\n  hasRepetitivePattern(name) {\n    return /([a-z])\\1/i.test(name) || /([a-z]{2,}).*\\1/i.test(name);\n  }\n\n  containsCommonWords(name) {\n    const commonWords = ['app', 'web', 'net', 'tech', 'pro', 'max', 'plus', 'hub', 'lab'];\n    return commonWords.some(word => name.toLowerCase().includes(word));\n  }\n\n  isInventedWord(name) {\n    // Simple check - if it's not in common dictionaries\n    const commonWords = ['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'man', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'its', 'let', 'put', 'say', 'she', 'too', 'use'];\n    return !commonWords.includes(name.toLowerCase());\n  }\n\n  hasVisualAppeal(name) {\n    // Check for balanced letter shapes\n    const roundLetters = name.match(/[aeoubdpqr]/gi) || [];\n    const straightLetters = name.match(/[iltfhk]/gi) || [];\n    return roundLetters.length > 0 && straightLetters.length > 0;\n  }\n\n  hasEmotionalResonance(name) {\n    const positiveWords = ['bright', 'smart', 'swift', 'clear', 'pure', 'true', 'strong', 'bold'];\n    return positiveWords.some(word => name.toLowerCase().includes(word.substring(0, 3)));\n  }\n\n  isScalable(name) {\n    // Avoid product-specific terms\n    const productTerms = ['app', 'software', 'tool', 'platform', 'system'];\n    return !productTerms.some(term => name.toLowerCase().includes(term));\n  }\n\n  hasDomainPotential(name) {\n    // Short names have better domain potential\n    return name.length <= 10 && !name.includes('-') && !name.includes('_');\n  }\n\n  isProfessional(name) {\n    // Avoid playful or casual elements\n    const casualElements = ['fun', 'cool', 'awesome', 'super', 'mega'];\n    return !casualElements.some(element => name.toLowerCase().includes(element));\n  }\n\n  isConsumerFriendly(name) {\n    // Easy to remember and pronounce\n    return name.length <= 8 && this.countSyllables(name) <= 3;\n  }\n\n  hasGlobalAppeal(name) {\n    // Avoid culture-specific references\n    const culturalTerms = ['american', 'usa', 'euro', 'asia'];\n    return !culturalTerms.some(term => name.toLowerCase().includes(term));\n  }\n\n  // Generate description for a name\n  generateDescription(name, industry) {\n    const descriptions = {\n      tech: `Perfect for ${industry} platforms and software solutions`,\n      saas: `Ideal for productivity and collaboration tools`,\n      fintech: `Great for financial services and payment platforms`,\n      healthcare: `Suitable for healthcare and wellness applications`,\n      ai: `Perfect for artificial intelligence and machine learning platforms`\n    };\n    \n    return descriptions[industry] || descriptions.tech;\n  }\n\n  // Generate reasoning for a name\n  generateReasoning(name, industry, scores) {\n    const reasons = [];\n    \n    if (scores.memorability >= 8) reasons.push('Highly memorable');\n    if (scores.pronunciation >= 8) reasons.push('Easy to pronounce');\n    if (scores.uniqueness >= 8) reasons.push('Unique and distinctive');\n    if (scores.brandability >= 8) reasons.push('Strong brand potential');\n    \n    if (reasons.length === 0) reasons.push('Solid naming choice');\n    \n    return reasons.join(', ');\n  }\n}\n\n// Export the AI naming engine\nexport default AINameGenerator;\n\n// Example usage:\n// const generator = new AINameGenerator();\n// const names = generator.generateNames({\n//   industry: 'tech',\n//   keywords: ['data', 'analytics'],\n//   style: 'modern',\n//   targetAudience: 'b2b',\n//   brandPersonality: 'innovation'\n// });"
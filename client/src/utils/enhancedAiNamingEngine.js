class EnhancedAINameGenerator {\n  constructor() {\n    this.industryIntelligence = {\n      tech: {\n        metaphors: ['quantum', 'neural', 'fusion', 'nexus', 'vertex', 'apex', 'zenith', 'matrix'],\n        emotions: ['innovation', 'disruption', 'precision', 'velocity', 'breakthrough', 'evolution'],\n        patterns: ['compound-tech', 'invented-scientific', 'metaphor-future', 'greek-tech'],\n        avoid: ['generic-tech', 'overused-cloud', 'cliche-digital'],\n        successfulPatterns: ['Google', 'Tesla', 'Nvidia', 'Palantir', 'Anthropic']\n      },\n      healthcare: {\n        metaphors: ['vital', 'harmony', 'beacon', 'sanctuary', 'genesis', 'remedy', 'pulse', 'care'],\n        emotions: ['trust', 'care', 'healing', 'hope', 'strength', 'wellness', 'vitality'],\n        patterns: ['latin-medical', 'compound-care', 'metaphor-life', 'trust-building'],\n        avoid: ['cold-clinical', 'scary-medical', 'impersonal'],\n        successfulPatterns: ['Moderna', 'Illumina', 'Veracyte', 'Guardant', 'Tempus']\n      },\n      fintech: {\n        metaphors: ['vault', 'bridge', 'compass', 'anchor', 'summit', 'fortress', 'ledger', 'mint'],\n        emotions: ['security', 'growth', 'trust', 'prosperity', 'stability', 'confidence'],\n        patterns: ['compound-financial', 'metaphor-security', 'invented-trust', 'latin-finance'],\n        avoid: ['risky-gambling', 'complex-financial', 'intimidating'],\n        successfulPatterns: ['Stripe', 'Plaid', 'Robinhood', 'Coinbase', 'Affirm']\n      },\n      saas: {\n        metaphors: ['flow', 'sync', 'hub', 'stack', 'forge', 'craft', 'build', 'scale'],\n        emotions: ['efficiency', 'productivity', 'simplicity', 'power', 'growth'],\n        patterns: ['compound-productivity', 'metaphor-tools', 'invented-workflow'],\n        avoid: ['complex-enterprise', 'boring-corporate', 'generic-software'],\n        successfulPatterns: ['Slack', 'Notion', 'Figma', 'Airtable', 'Zapier']\n      },\n      ai: {\n        metaphors: ['mind', 'brain', 'synapse', 'cortex', 'neural', 'cognitive', 'sentient'],\n        emotions: ['intelligence', 'learning', 'insight', 'understanding', 'wisdom'],\n        patterns: ['compound-intelligence', 'metaphor-mind', 'invented-cognitive'],\n        avoid: ['scary-ai', 'terminator-references', 'overly-technical'],\n        successfulPatterns: ['OpenAI', 'Anthropic', 'Cohere', 'Hugging Face', 'Replicate']\n      }\n    };\n    \n    this.creativeTechniques = {\n      metaphorical: this.generateMetaphoricalNames.bind(this),\n      emotional: this.generateEmotionalNames.bind(this),\n      portmanteau: this.generatePortmanteauNames.bind(this),\n      invented: this.generateInventedWords.bind(this),\n      cultural: this.generateCulturalNames.bind(this),\n      compound: this.generateCompoundNames.bind(this)\n    };\n  }\n\n  generateIntelligentNames(input) {\n    const { industry, keywords, style, description } = input;\n    console.log('ðŸ§  Generating intelligent names for:', { industry, keywords, style });\n    \n    // Generate names using multiple sophisticated techniques\n    const techniques = [\n      this.generateMetaphoricalNames(input),\n      this.generateEmotionalNames(input),\n      this.generatePortmanteauNames(input),\n      this.generateInventedWords(input),\n      this.generateCulturalNames(input),\n      this.generateCompoundNames(input),\n      this.generateBrandableNeologisms(input),\n      this.generateContextualNames(input)\n    ];\n    \n    // Combine all generated names\n    const allNames = techniques.flat();\n    console.log('ðŸŽ¯ Generated', allNames.length, 'total names before filtering');\n    \n    // Apply intelligent filtering\n    const filteredNames = this.applyIntelligentFiltering(allNames, input);\n    console.log('âœ¨ Filtered to', filteredNames.length, 'high-quality names');\n    \n    // Rank by quality and return top 50\n    const rankedNames = this.rankByQuality(filteredNames, input);\n    return rankedNames.slice(0, 50);\n  }\n\n  generateMetaphoricalNames(input) {\n    const intelligence = this.industryIntelligence[input.industry] || this.industryIntelligence.tech;\n    const metaphors = intelligence.metaphors;\n    const keywords = input.keywords || [];\n    \n    const names = [];\n    \n    metaphors.forEach(metaphor => {\n      keywords.forEach(keyword => {\n        // Direct combinations\n        names.push(this.createNameObject(`${metaphor}${this.capitalize(keyword)}`, input, 'metaphorical'));\n        names.push(this.createNameObject(`${this.capitalize(keyword)}${this.capitalize(metaphor)}`, input, 'metaphorical'));\n        \n        // With connectors\n        names.push(this.createNameObject(`${metaphor}${keyword}`, input, 'metaphorical'));\n        names.push(this.createNameObject(`${keyword}${metaphor}`, input, 'metaphorical'));\n      });\n      \n      // Standalone metaphors with suffixes\n      names.push(this.createNameObject(`${metaphor}Labs`, input, 'metaphorical'));\n      names.push(this.createNameObject(`${metaphor}Works`, input, 'metaphorical'));\n      names.push(this.createNameObject(`${metaphor}Tech`, input, 'metaphorical'));\n    });\n    \n    return names;\n  }\n\n  generateEmotionalNames(input) {\n    const intelligence = this.industryIntelligence[input.industry] || this.industryIntelligence.tech;\n    const emotions = intelligence.emotions;\n    const keywords = input.keywords || [];\n    \n    const names = [];\n    \n    emotions.forEach(emotion => {\n      keywords.forEach(keyword => {\n        // Emotional + keyword combinations\n        names.push(this.createNameObject(`${this.capitalize(emotion)}${this.capitalize(keyword)}`, input, 'emotional'));\n        names.push(this.createNameObject(`${this.capitalize(keyword)}${this.capitalize(emotion)}`, input, 'emotional'));\n      });\n      \n      // Emotional concepts with tech suffixes\n      names.push(this.createNameObject(`${emotion}Flow`, input, 'emotional'));\n      names.push(this.createNameObject(`${emotion}Sync`, input, 'emotional'));\n      names.push(this.createNameObject(`${emotion}Hub`, input, 'emotional'));\n    });\n    \n    return names;\n  }\n\n  generatePortmanteauNames(input) {\n    const keywords = input.keywords || [];\n    const names = [];\n    \n    // Blend keywords with industry terms\n    const industryTerms = ['tech', 'lab', 'works', 'flow', 'sync', 'hub', 'forge', 'craft'];\n    \n    keywords.forEach(keyword => {\n      industryTerms.forEach(term => {\n        // Create portmanteau by blending parts of words\n        const blend1 = this.blendWords(keyword, term);\n        const blend2 = this.blendWords(term, keyword);\n        \n        if (blend1) names.push(this.createNameObject(blend1, input, 'portmanteau'));\n        if (blend2) names.push(this.createNameObject(blend2, input, 'portmanteau'));\n      });\n    });\n    \n    // Blend keywords with each other\n    for (let i = 0; i < keywords.length; i++) {\n      for (let j = i + 1; j < keywords.length; j++) {\n        const blend = this.blendWords(keywords[i], keywords[j]);\n        if (blend) names.push(this.createNameObject(blend, input, 'portmanteau'));\n      }\n    }\n    \n    return names;\n  }\n\n  generateInventedWords(input) {\n    const keywords = input.keywords || [];\n    const names = [];\n    \n    // Create invented words using phonetic patterns\n    const prefixes = ['neo', 'pro', 'meta', 'ultra', 'hyper', 'omni', 'zen', 'flux'];\n    const suffixes = ['ify', 'ize', 'ly', 'io', 'ax', 'ex', 'ix', 'on'];\n    \n    keywords.forEach(keyword => {\n      prefixes.forEach(prefix => {\n        names.push(this.createNameObject(`${prefix}${keyword}`, input, 'invented'));\n      });\n      \n      suffixes.forEach(suffix => {\n        names.push(this.createNameObject(`${keyword}${suffix}`, input, 'invented'));\n      });\n    });\n    \n    // Generate completely new words using phonetic patterns\n    const phonemes = ['qu', 'zr', 'vx', 'zy', 'nx', 'rx'];\n    phonemes.forEach(phoneme => {\n      keywords.forEach(keyword => {\n        names.push(this.createNameObject(`${phoneme}${keyword.slice(1)}`, input, 'invented'));\n      });\n    });\n    \n    return names;\n  }\n\n  generateCulturalNames(input) {\n    const keywords = input.keywords || [];\n    const names = [];\n    \n    // Latin/Greek inspired names\n    const latinPrefixes = ['astra', 'nova', 'terra', 'aqua', 'ignis', 'aero', 'vita', 'lux'];\n    const greekSuffixes = ['os', 'is', 'us', 'on', 'ia', 'ys'];\n    \n    keywords.forEach(keyword => {\n      latinPrefixes.forEach(prefix => {\n        names.push(this.createNameObject(`${prefix}${keyword}`, input, 'cultural'));\n      });\n      \n      greekSuffixes.forEach(suffix => {\n        names.push(this.createNameObject(`${keyword}${suffix}`, input, 'cultural'));\n      });\n    });\n    \n    return names;\n  }\n\n  generateCompoundNames(input) {\n    const keywords = input.keywords || [];\n    const intelligence = this.industryIntelligence[input.industry] || this.industryIntelligence.tech;\n    const names = [];\n    \n    // Compound with industry-specific terms\n    const industryTerms = ['Labs', 'Works', 'Tech', 'Systems', 'Solutions', 'Platform', 'Engine'];\n    \n    keywords.forEach(keyword => {\n      industryTerms.forEach(term => {\n        names.push(this.createNameObject(`${this.capitalize(keyword)}${term}`, input, 'compound'));\n      });\n    });\n    \n    // Compound keywords with metaphors\n    intelligence.metaphors.forEach(metaphor => {\n      keywords.forEach(keyword => {\n        names.push(this.createNameObject(`${this.capitalize(metaphor)}${this.capitalize(keyword)}`, input, 'compound'));\n      });\n    });\n    \n    return names;\n  }\n\n  generateBrandableNeologisms(input) {\n    const keywords = input.keywords || [];\n    const names = [];\n    \n    // Create brandable new words\n    const brandablePrefixes = ['zi', 'qu', 'vr', 'nx', 'zy', 'rx'];\n    const brandableSuffixes = ['ly', 'fy', 'io', 'ax', 'ex', 'on'];\n    \n    keywords.forEach(keyword => {\n      brandablePrefixes.forEach(prefix => {\n        const core = keyword.slice(0, -1);\n        names.push(this.createNameObject(`${prefix}${core}`, input, 'neologism'));\n      });\n      \n      brandableSuffixes.forEach(suffix => {\n        const core = keyword.slice(0, -1);\n        names.push(this.createNameObject(`${core}${suffix}`, input, 'neologism'));\n      });\n    });\n    \n    return names;\n  }\n\n  generateContextualNames(input) {\n    const { description, industry } = input;\n    const names = [];\n    \n    if (description) {\n      // Extract concepts from description\n      const concepts = this.extractConcepts(description);\n      const intelligence = this.industryIntelligence[industry] || this.industryIntelligence.tech;\n      \n      concepts.forEach(concept => {\n        intelligence.metaphors.forEach(metaphor => {\n          names.push(this.createNameObject(`${this.capitalize(concept)}${this.capitalize(metaphor)}`, input, 'contextual'));\n        });\n      });\n    }\n    \n    return names;\n  }\n\n  createNameObject(name, input, technique) {\n    const quality = this.calculateAdvancedQuality(name, input);\n    \n    return {\n      name: this.capitalize(name),\n      score: quality.overallScore,\n      memorability: quality.memorability,\n      pronunciation: quality.pronunciation,\n      uniqueness: quality.uniqueness,\n      brandability: quality.brandability,\n      description: this.generateDescription(name, input, technique),\n      reasoning: this.generateReasoning(name, input, technique, quality),\n      technique: technique,\n      industry: input.industry\n    };\n  }\n\n  calculateAdvancedQuality(name, input) {\n    const memorability = this.calculateMemorability(name);\n    const pronunciation = this.calculatePronunciation(name);\n    const uniqueness = this.calculateUniqueness(name, input);\n    const brandability = this.calculateBrandability(name, input);\n    const marketAppeal = this.calculateMarketAppeal(name, input);\n    const creativity = this.calculateCreativity(name, input);\n    \n    const overallScore = (\n      memorability * 0.25 +\n      pronunciation * 0.20 +\n      uniqueness * 0.20 +\n      brandability * 0.20 +\n      marketAppeal * 0.15\n    );\n    \n    return {\n      overallScore: Math.round(overallScore * 10) / 10,\n      memorability: Math.round(memorability * 10) / 10,\n      pronunciation: Math.round(pronunciation * 10) / 10,\n      uniqueness: Math.round(uniqueness * 10) / 10,\n      brandability: Math.round(brandability * 10) / 10,\n      marketAppeal: Math.round(marketAppeal * 10) / 10,\n      creativity: Math.round(creativity * 10) / 10\n    };\n  }\n\n  calculateMemorability(name) {\n    let score = 10;\n    \n    // Length penalty\n    if (name.length > 12) score -= 2;\n    if (name.length > 15) score -= 2;\n    if (name.length < 4) score -= 1;\n    \n    // Syllable count (optimal 2-3)\n    const syllables = this.countSyllables(name);\n    if (syllables === 2 || syllables === 3) score += 1;\n    if (syllables > 4) score -= 2;\n    \n    // Pattern recognition\n    if (this.hasRepeatingPatterns(name)) score += 1;\n    if (this.hasAlliteration(name)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  calculatePronunciation(name) {\n    let score = 10;\n    \n    // Consonant clusters\n    const consonantClusters = (name.match(/[bcdfghjklmnpqrstvwxyz]{3,}/gi) || []).length;\n    score -= consonantClusters * 2;\n    \n    // Vowel balance\n    const vowels = (name.match(/[aeiou]/gi) || []).length;\n    const consonants = name.length - vowels;\n    const ratio = vowels / consonants;\n    if (ratio < 0.2 || ratio > 0.8) score -= 1;\n    \n    // Common phonetic patterns\n    if (this.hasCommonPhoneticPatterns(name)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  calculateUniqueness(name, input) {\n    let score = 8; // Base uniqueness score\n    \n    // Check against common words\n    if (this.isCommonWord(name)) score -= 3;\n    \n    // Check industry differentiation\n    const intelligence = this.industryIntelligence[input.industry];\n    if (intelligence && intelligence.avoid.some(pattern => name.toLowerCase().includes(pattern))) {\n      score -= 2;\n    }\n    \n    // Invented word bonus\n    if (this.isInventedWord(name)) score += 2;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  calculateBrandability(name, input) {\n    let score = 8;\n    \n    // Visual appeal\n    if (this.hasVisualAppeal(name)) score += 1;\n    \n    // Domain potential\n    if (this.hasDomainPotential(name)) score += 1;\n    \n    // Emotional resonance\n    if (this.hasEmotionalResonance(name, input)) score += 1;\n    \n    // Scalability\n    if (this.hasScalabilityPotential(name)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  calculateMarketAppeal(name, input) {\n    let score = 8;\n    \n    const intelligence = this.industryIntelligence[input.industry];\n    if (intelligence) {\n      // Industry alignment\n      if (intelligence.emotions.some(emotion => name.toLowerCase().includes(emotion))) score += 1;\n      if (intelligence.metaphors.some(metaphor => name.toLowerCase().includes(metaphor))) score += 1;\n    }\n    \n    // Global appeal\n    if (this.hasGlobalAppeal(name)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  calculateCreativity(name, input) {\n    let score = 7;\n    \n    // Technique bonus\n    if (this.isPortmanteau(name)) score += 1;\n    if (this.isInventedWord(name)) score += 2;\n    if (this.isMetaphorical(name, input)) score += 1;\n    \n    return Math.max(1, Math.min(10, score));\n  }\n\n  generateDescription(name, input, technique) {\n    const intelligence = this.industryIntelligence[input.industry] || this.industryIntelligence.tech;\n    const templates = {\n      metaphorical: [\n        `Combines powerful metaphorical concepts with ${input.industry} innovation.`,\n        `Evokes strength and reliability perfect for ${input.industry} ventures.`,\n        `Creates strong visual and emotional associations for your brand.`\n      ],\n      emotional: [\n        `Designed to evoke ${intelligence.emotions[0]} and trust in your target market.`,\n        `Builds emotional connection with customers through powerful associations.`,\n        `Creates positive emotional response and brand loyalty.`\n      ],\n      portmanteau: [\n        `Clever blend of concepts that creates a unique and memorable brand identity.`,\n        `Innovative word combination that stands out in the ${input.industry} space.`,\n        `Creative fusion that captures multiple brand values in one name.`\n      ],\n      invented: [\n        `Completely original name that ensures unique brand positioning.`,\n        `Fresh, invented word that creates strong trademark potential.`,\n        `Unique creation that allows you to define your own brand meaning.`\n      ],\n      cultural: [\n        `Draws from classical roots to convey authority and timeless appeal.`,\n        `Cultural sophistication that appeals to educated target markets.`,\n        `Classical foundation with modern ${input.industry} relevance.`\n      ],\n      compound: [\n        `Strategic combination that clearly communicates your ${input.industry} focus.`,\n        `Professional compound name that builds immediate industry credibility.`,\n        `Clear, descriptive name that helps customers understand your value.`\n      ]\n    };\n    \n    const templateArray = templates[technique] || templates.compound;\n    return templateArray[Math.floor(Math.random() * templateArray.length)];\n  }\n\n  generateReasoning(name, input, technique, quality) {\n    const reasons = [];\n    \n    // Quality-based reasoning\n    if (quality.memorability >= 8.5) reasons.push('highly memorable due to optimal length and phonetic structure');\n    if (quality.pronunciation >= 8.5) reasons.push('easy to pronounce with natural vowel-consonant balance');\n    if (quality.uniqueness >= 8.5) reasons.push('unique positioning that differentiates from competitors');\n    if (quality.brandability >= 8.5) reasons.push('strong brandability with excellent visual and emotional appeal');\n    \n    // Technique-based reasoning\n    const techniqueReasons = {\n      metaphorical: 'uses powerful metaphorical concepts that create strong brand associations',\n      emotional: 'designed to evoke specific emotions that resonate with your target audience',\n      portmanteau: 'clever word blending creates a unique identity while maintaining meaning',\n      invented: 'completely original creation ensures unique trademark and brand positioning',\n      cultural: 'draws from classical roots to convey authority and sophistication',\n      compound: 'strategic combination clearly communicates industry focus and expertise'\n    };\n    \n    reasons.push(techniqueReasons[technique] || 'professionally crafted for maximum brand impact');\n    \n    // Industry-specific reasoning\n    const intelligence = this.industryIntelligence[input.industry];\n    if (intelligence) {\n      reasons.push(`optimized for ${input.industry} market expectations and industry trends`);\n    }\n    \n    return `This name ${reasons.join(', ')}.`;\n  }\n\n  applyIntelligentFiltering(names, input) {\n    return names.filter(name => {\n      // Quality thresholds\n      if (name.score < 7.0) return false;\n      if (name.memorability < 6.0) return false;\n      if (name.pronunciation < 6.0) return false;\n      \n      // Length constraints\n      if (name.name.length < 3 || name.name.length > 20) return false;\n      \n      // Avoid problematic patterns\n      const intelligence = this.industryIntelligence[input.industry];\n      if (intelligence && intelligence.avoid.some(pattern => \n        name.name.toLowerCase().includes(pattern.replace('-', ''))\n      )) return false;\n      \n      return true;\n    });\n  }\n\n  rankByQuality(names, input) {\n    return names.sort((a, b) => {\n      // Primary sort by overall score\n      if (b.score !== a.score) return b.score - a.score;\n      \n      // Secondary sort by brandability\n      if (b.brandability !== a.brandability) return b.brandability - a.brandability;\n      \n      // Tertiary sort by uniqueness\n      return b.uniqueness - a.uniqueness;\n    });\n  }\n\n  // Helper methods\n  capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n  }\n\n  blendWords(word1, word2) {\n    if (word1.length < 3 || word2.length < 3) return null;\n    \n    // Take first part of word1 and last part of word2\n    const part1 = word1.slice(0, Math.ceil(word1.length * 0.6));\n    const part2 = word2.slice(Math.floor(word2.length * 0.4));\n    \n    const blend = part1 + part2;\n    return blend.length >= 4 && blend.length <= 15 ? blend : null;\n  }\n\n  extractConcepts(text) {\n    // Simple concept extraction from description\n    const words = text.toLowerCase().split(/\\s+/);\n    return words.filter(word => \n      word.length > 4 && \n      !['the', 'and', 'for', 'with', 'that', 'this', 'will', 'have', 'from'].includes(word)\n    ).slice(0, 5);\n  }\n\n  countSyllables(word) {\n    return (word.toLowerCase().match(/[aeiouy]+/g) || []).length;\n  }\n\n  hasRepeatingPatterns(name) {\n    return /(..).*\\1/.test(name.toLowerCase());\n  }\n\n  hasAlliteration(name) {\n    const words = name.split(/(?=[A-Z])/);\n    if (words.length < 2) return false;\n    return words[0][0].toLowerCase() === words[1][0].toLowerCase();\n  }\n\n  hasCommonPhoneticPatterns(name) {\n    const patterns = ['ch', 'sh', 'th', 'ph', 'ck', 'ng'];\n    return patterns.some(pattern => name.toLowerCase().includes(pattern));\n  }\n\n  isCommonWord(name) {\n    const commonWords = ['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'man', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'its', 'let', 'put', 'say', 'she', 'too', 'use'];\n    return commonWords.includes(name.toLowerCase());\n  }\n\n  isInventedWord(name) {\n    // Simple heuristic: contains uncommon letter combinations\n    const uncommonPatterns = ['zr', 'vx', 'qz', 'nx', 'rx', 'zy'];\n    return uncommonPatterns.some(pattern => name.toLowerCase().includes(pattern));\n  }\n\n  hasVisualAppeal(name) {\n    // Names with good visual balance\n    return name.length >= 5 && name.length <= 12 && /[aeiou]/i.test(name);\n  }\n\n  hasDomainPotential(name) {\n    // Good for domain names\n    return name.length <= 15 && !/[^a-zA-Z0-9]/.test(name);\n  }\n\n  hasEmotionalResonance(name, input) {\n    const intelligence = this.industryIntelligence[input.industry];\n    if (!intelligence) return false;\n    return intelligence.emotions.some(emotion => \n      name.toLowerCase().includes(emotion.slice(0, 4))\n    );\n  }\n\n  hasScalabilityPotential(name) {\n    // Not too specific, allows for growth\n    const specificTerms = ['app', 'web', 'site', 'blog', 'shop'];\n    return !specificTerms.some(term => name.toLowerCase().includes(term));\n  }\n\n  hasGlobalAppeal(name) {\n    // Easy to pronounce internationally\n    const difficultCombinations = ['th', 'zh', 'tch', 'dge'];\n    return !difficultCombinations.some(combo => name.toLowerCase().includes(combo));\n  }\n\n  isPortmanteau(name) {\n    // Heuristic: likely a blend if it has characteristics of two words\n    return name.length >= 6 && name.length <= 12;\n  }\n\n  isMetaphorical(name, input) {\n    const intelligence = this.industryIntelligence[input.industry];\n    if (!intelligence) return false;\n    return intelligence.metaphors.some(metaphor => \n      name.toLowerCase().includes(metaphor)\n    );\n  }\n}\n\nexport default EnhancedAINameGenerator;"
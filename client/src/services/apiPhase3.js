// Enhanced API Service for Phase 3 - Backend Integration\n// Adds loading states, progress tracking, and enhanced error handling\n\nimport apiService from './api';\n\nclass APIServicePhase3 {\n  constructor() {\n    this.baseService = apiService;\n    this.loadingCallbacks = new Map();\n    this.progressCallbacks = new Map();\n  }\n\n  // Enhanced name generation with progress tracking\n  async generateNamesWithProgress(formData, callbacks = {}) {\n    const {\n      onStageChange = () => {},\n      onProgress = () => {},\n      onError = () => {},\n      onSuccess = () => {}\n    } = callbacks;\n\n    console.log('🚀 Phase 3 Enhanced Name Generation Starting...');\n    \n    try {\n      // Stage 1: Connecting to backend\n      onStageChange('connecting');\n      onProgress(10);\n      \n      // Health check first\n      const healthCheck = await this.baseService.healthCheck();\n      if (!healthCheck.success) {\n        throw new Error('Backend service unavailable');\n      }\n      \n      onProgress(20);\n      \n      // Stage 2: Processing input\n      onStageChange('processing');\n      onProgress(30);\n      \n      // Validate and prepare data\n      const requestData = {\n        keywords: formData.keywords || ['startup'],\n        industry: formData.industry || 'tech',\n        style: formData.style || 'modern',\n        count: formData.count || 50,\n        description: formData.description\n      };\n      \n      // Add small delay for UX (shows processing stage)\n      await this.delay(800);\n      onProgress(40);\n      \n      // Stage 3: Generating names\n      onStageChange('generating');\n      onProgress(50);\n      \n      const response = await this.baseService.generateNames(requestData);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Name generation failed');\n      }\n      \n      onProgress(70);\n      \n      // Stage 4: Scoring and analysis\n      onStageChange('scoring');\n      onProgress(80);\n      \n      // Add delay for scoring stage UX\n      await this.delay(600);\n      onProgress(90);\n      \n      // Stage 5: Finalizing\n      onStageChange('finalizing');\n      onProgress(95);\n      \n      // Final processing\n      await this.delay(400);\n      onProgress(100);\n      \n      console.log('✅ Phase 3 Enhanced Generation Complete:', response);\n      onSuccess(response);\n      \n      return response;\n      \n    } catch (error) {\n      console.error('❌ Phase 3 Enhanced Generation Failed:', error);\n      onError(error.message || 'Name generation failed');\n      throw error;\n    }\n  }\n\n  // Enhanced session management with progress\n  async createSessionWithProgress(formData, callbacks = {}) {\n    const { onProgress = () => {} } = callbacks;\n    \n    try {\n      onProgress(10);\n      \n      // Create session data\n      const sessionId = Date.now().toString();\n      const sessionData = {\n        formData,\n        timestamp: new Date().toISOString(),\n        phase3Enhanced: true,\n        status: 'created'\n      };\n      \n      onProgress(50);\n      \n      // Store in localStorage\n      localStorage.setItem(`naming_session_${sessionId}`, JSON.stringify(sessionData));\n      \n      onProgress(100);\n      \n      return {\n        success: true,\n        sessionId,\n        sessionData\n      };\n      \n    } catch (error) {\n      console.error('❌ Session creation failed:', error);\n      throw error;\n    }\n  }\n\n  // Enhanced session retrieval\n  async getSessionWithFallback(sessionId) {\n    try {\n      // Try backend first\n      const backendResponse = await this.baseService.getSession(sessionId);\n      \n      if (backendResponse.success) {\n        return backendResponse;\n      }\n      \n      // Fallback to localStorage\n      const localData = localStorage.getItem(`naming_session_${sessionId}`);\n      if (localData) {\n        const sessionData = JSON.parse(localData);\n        return {\n          success: true,\n          data: sessionData,\n          source: 'localStorage'\n        };\n      }\n      \n      throw new Error('Session not found');\n      \n    } catch (error) {\n      console.error('❌ Session retrieval failed:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Enhanced domain checking with progress\n  async checkDomainsWithProgress(names, callbacks = {}) {\n    const { onProgress = () => {} } = callbacks;\n    \n    try {\n      const results = [];\n      const total = names.length;\n      \n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        \n        try {\n          const domainResult = await this.baseService.checkDomainAvailability(name.name);\n          results.push({\n            ...name,\n            domainInfo: domainResult\n          });\n        } catch (error) {\n          results.push({\n            ...name,\n            domainInfo: { error: true, message: 'Check failed' }\n          });\n        }\n        \n        onProgress(Math.round(((i + 1) / total) * 100));\n        \n        // Small delay to prevent rate limiting\n        if (i < names.length - 1) {\n          await this.delay(100);\n        }\n      }\n      \n      return {\n        success: true,\n        results\n      };\n      \n    } catch (error) {\n      console.error('❌ Domain checking failed:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Enhanced error handling with user-friendly messages\n  handleEnhancedError(error, context = 'API request') {\n    console.error(`❌ Phase 3 ${context} failed:`, error);\n    \n    // Network errors\n    if (error.name === 'AbortError') {\n      return {\n        type: 'timeout',\n        message: 'Request timed out. Please check your connection and try again.',\n        action: 'retry'\n      };\n    }\n    \n    if (error.message.includes('Failed to fetch')) {\n      return {\n        type: 'network',\n        message: 'Unable to connect to our servers. Please check your internet connection.',\n        action: 'retry'\n      };\n    }\n    \n    // API errors\n    if (error.message.includes('HTTP 401')) {\n      return {\n        type: 'auth',\n        message: 'Authentication required. Please refresh the page.',\n        action: 'refresh'\n      };\n    }\n    \n    if (error.message.includes('HTTP 429')) {\n      return {\n        type: 'rate_limit',\n        message: 'Too many requests. Please wait a moment and try again.',\n        action: 'wait'\n      };\n    }\n    \n    if (error.message.includes('HTTP 500')) {\n      return {\n        type: 'server',\n        message: 'Server error. Our team has been notified. Please try again.',\n        action: 'retry'\n      };\n    }\n    \n    // Backend specific errors\n    if (error.message.includes('Backend service unavailable')) {\n      return {\n        type: 'backend',\n        message: 'Our AI service is temporarily unavailable. Please try again in a moment.',\n        action: 'retry'\n      };\n    }\n    \n    if (error.message.includes('Name generation failed')) {\n      return {\n        type: 'generation',\n        message: 'Name generation failed. Please try different keywords or settings.',\n        action: 'modify'\n      };\n    }\n    \n    // Generic error\n    return {\n      type: 'generic',\n      message: error.message || 'An unexpected error occurred. Please try again.',\n      action: 'retry'\n    };\n  }\n\n  // Performance monitoring\n  async measurePerformance(operation, operationFn) {\n    const startTime = performance.now();\n    \n    try {\n      const result = await operationFn();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.log(`📊 Performance: ${operation} took ${Math.round(duration)}ms`);\n      \n      // Track performance metrics\n      this.trackPerformance(operation, duration, true);\n      \n      return result;\n      \n    } catch (error) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.error(`📊 Performance: ${operation} failed after ${Math.round(duration)}ms`);\n      \n      // Track failed performance\n      this.trackPerformance(operation, duration, false);\n      \n      throw error;\n    }\n  }\n\n  // Performance tracking\n  trackPerformance(operation, duration, success) {\n    const performanceData = {\n      operation,\n      duration: Math.round(duration),\n      success,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent\n    };\n    \n    // Store in localStorage for analytics\n    const existingData = JSON.parse(localStorage.getItem('performance_metrics') || '[]');\n    existingData.push(performanceData);\n    \n    // Keep only last 100 entries\n    if (existingData.length > 100) {\n      existingData.splice(0, existingData.length - 100);\n    }\n    \n    localStorage.setItem('performance_metrics', JSON.stringify(existingData));\n  }\n\n  // Utility methods\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Health check with enhanced reporting\n  async enhancedHealthCheck() {\n    try {\n      const startTime = performance.now();\n      const response = await this.baseService.healthCheck();\n      const endTime = performance.now();\n      \n      return {\n        ...response,\n        responseTime: Math.round(endTime - startTime),\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  // Batch operations with progress\n  async batchOperation(items, operationFn, callbacks = {}) {\n    const { onProgress = () => {}, onItemComplete = () => {} } = callbacks;\n    \n    const results = [];\n    const total = items.length;\n    \n    for (let i = 0; i < items.length; i++) {\n      try {\n        const result = await operationFn(items[i], i);\n        results.push(result);\n        onItemComplete(result, i);\n      } catch (error) {\n        results.push({ error: error.message, index: i });\n      }\n      \n      onProgress(Math.round(((i + 1) / total) * 100));\n    }\n    \n    return results;\n  }\n}\n\n// Create and export enhanced API service\nconst apiServicePhase3 = new APIServicePhase3();\nexport default apiServicePhase3;"
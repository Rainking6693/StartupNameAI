#!/usr/bin/env node\n\n/**\n * Deployment Testing Script\n * Tests the build process and verifies deployment readiness\n */\n\nconst { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\nclass DeploymentTester {\n  constructor() {\n    this.results = {\n      packageInstall: false,\n      buildProcess: false,\n      buildOutput: false,\n      dependencies: false,\n      overall: false\n    };\n    this.errors = [];\n  }\n\n  log(message, type = 'info') {\n    const timestamp = new Date().toISOString();\n    const prefix = {\n      info: '‚úÖ',\n      error: '‚ùå',\n      warning: '‚ö†Ô∏è',\n      success: 'üéâ'\n    }[type] || '‚ÑπÔ∏è';\n    \n    console.log(`${prefix} [${timestamp}] ${message}`);\n  }\n\n  async testPackageInstallation() {\n    this.log('Testing package installation...', 'info');\n    \n    try {\n      // Test root package installation\n      this.log('Installing root dependencies...', 'info');\n      execSync('npm install', { \n        cwd: process.cwd(),\n        stdio: 'pipe'\n      });\n      \n      // Test client package installation\n      this.log('Installing client dependencies...', 'info');\n      execSync('npm install', { \n        cwd: path.join(process.cwd(), 'client'),\n        stdio: 'pipe'\n      });\n      \n      this.results.packageInstall = true;\n      this.log('Package installation successful!', 'success');\n      return true;\n    } catch (error) {\n      this.errors.push(`Package installation failed: ${error.message}`);\n      this.log(`Package installation failed: ${error.message}`, 'error');\n      return false;\n    }\n  }\n\n  async testDependencyVersions() {\n    this.log('Checking dependency versions...', 'info');\n    \n    try {\n      const clientPackageJson = JSON.parse(\n        fs.readFileSync(path.join(process.cwd(), 'client', 'package.json'), 'utf8')\n      );\n      \n      const reactVersion = clientPackageJson.dependencies.react;\n      const reactDomVersion = clientPackageJson.dependencies['react-dom'];\n      const overrideReact = clientPackageJson.overrides?.react;\n      const overrideReactDom = clientPackageJson.overrides?.['react-dom'];\n      \n      this.log(`React version: ${reactVersion}`, 'info');\n      this.log(`React DOM version: ${reactDomVersion}`, 'info');\n      this.log(`React override: ${overrideReact}`, 'info');\n      this.log(`React DOM override: ${overrideReactDom}`, 'info');\n      \n      // Check for version consistency\n      if (reactVersion === reactDomVersion && \n          overrideReact === overrideReactDom &&\n          reactVersion.includes('18.3.1')) {\n        this.results.dependencies = true;\n        this.log('Dependency versions are consistent!', 'success');\n        return true;\n      } else {\n        this.errors.push('Dependency versions are inconsistent');\n        this.log('Dependency versions are inconsistent', 'error');\n        return false;\n      }\n    } catch (error) {\n      this.errors.push(`Dependency check failed: ${error.message}`);\n      this.log(`Dependency check failed: ${error.message}`, 'error');\n      return false;\n    }\n  }\n\n  async testBuildProcess() {\n    this.log('Testing build process...', 'info');\n    \n    try {\n      // Run the build command\n      this.log('Running npm run build...', 'info');\n      const buildOutput = execSync('npm run build', { \n        cwd: process.cwd(),\n        stdio: 'pipe',\n        encoding: 'utf8'\n      });\n      \n      this.log('Build process completed successfully!', 'success');\n      this.results.buildProcess = true;\n      return true;\n    } catch (error) {\n      this.errors.push(`Build process failed: ${error.message}`);\n      this.log(`Build process failed: ${error.message}`, 'error');\n      return false;\n    }\n  }\n\n  async testBuildOutput() {\n    this.log('Verifying build output...', 'info');\n    \n    try {\n      const buildDir = path.join(process.cwd(), 'client', 'build');\n      \n      // Check if build directory exists\n      if (!fs.existsSync(buildDir)) {\n        this.errors.push('Build directory does not exist');\n        this.log('Build directory does not exist', 'error');\n        return false;\n      }\n      \n      // Check for essential files\n      const essentialFiles = ['index.html', 'static'];\n      for (const file of essentialFiles) {\n        const filePath = path.join(buildDir, file);\n        if (!fs.existsSync(filePath)) {\n          this.errors.push(`Essential file missing: ${file}`);\n          this.log(`Essential file missing: ${file}`, 'error');\n          return false;\n        }\n      }\n      \n      // Check build size\n      const stats = fs.statSync(path.join(buildDir, 'index.html'));\n      if (stats.size < 1000) {\n        this.errors.push('Build output seems too small');\n        this.log('Build output seems too small', 'warning');\n      }\n      \n      this.results.buildOutput = true;\n      this.log('Build output verification successful!', 'success');\n      return true;\n    } catch (error) {\n      this.errors.push(`Build output verification failed: ${error.message}`);\n      this.log(`Build output verification failed: ${error.message}`, 'error');\n      return false;\n    }\n  }\n\n  async runAllTests() {\n    this.log('Starting deployment testing...', 'info');\n    this.log('='.repeat(50), 'info');\n    \n    const tests = [\n      { name: 'Package Installation', fn: () => this.testPackageInstallation() },\n      { name: 'Dependency Versions', fn: () => this.testDependencyVersions() },\n      { name: 'Build Process', fn: () => this.testBuildProcess() },\n      { name: 'Build Output', fn: () => this.testBuildOutput() }\n    ];\n    \n    let allPassed = true;\n    \n    for (const test of tests) {\n      this.log(`\\nRunning test: ${test.name}`, 'info');\n      const result = await test.fn();\n      if (!result) {\n        allPassed = false;\n      }\n    }\n    \n    this.results.overall = allPassed;\n    \n    this.log('\\n' + '='.repeat(50), 'info');\n    this.log('DEPLOYMENT TESTING COMPLETE', 'info');\n    this.log('='.repeat(50), 'info');\n    \n    // Print results summary\n    this.printResults();\n    \n    return allPassed;\n  }\n\n  printResults() {\n    this.log('\\nTEST RESULTS SUMMARY:', 'info');\n    this.log('-'.repeat(30), 'info');\n    \n    Object.entries(this.results).forEach(([test, passed]) => {\n      const status = passed ? '‚úÖ PASS' : '‚ùå FAIL';\n      this.log(`${test}: ${status}`, passed ? 'success' : 'error');\n    });\n    \n    if (this.errors.length > 0) {\n      this.log('\\nERRORS ENCOUNTERED:', 'error');\n      this.log('-'.repeat(30), 'error');\n      this.errors.forEach(error => {\n        this.log(`‚Ä¢ ${error}`, 'error');\n      });\n    }\n    \n    const overallStatus = this.results.overall ? \n      'üéâ DEPLOYMENT READY - ALL TESTS PASSED!' : \n      '‚ùå DEPLOYMENT BLOCKED - TESTS FAILED';\n    \n    this.log(`\\n${overallStatus}`, this.results.overall ? 'success' : 'error');\n    \n    if (this.results.overall) {\n      this.log('\\nüöÄ Ready for Netlify deployment!', 'success');\n      this.log('Run: npm run deploy:production', 'info');\n    } else {\n      this.log('\\nüîß Fix the above issues before deployment', 'warning');\n    }\n  }\n}\n\n// Run the tests\nif (require.main === module) {\n  const tester = new DeploymentTester();\n  tester.runAllTests()\n    .then(success => {\n      process.exit(success ? 0 : 1);\n    })\n    .catch(error => {\n      console.error('‚ùå Testing failed with error:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = DeploymentTester;"
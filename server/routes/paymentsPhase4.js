const express = require('express');\nconst { body, validationResult } = require('express-validator');\nconst rateLimit = require('express-rate-limit');\nconst paymentService = require('../services/paymentService');\nconst { AppError, logger } = require('../middleware/errorHandler');\nconst { pool } = require('../config/database');\n\nconst router = express.Router();\n\n// Rate limiting for payment endpoints\nconst paymentLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 payment attempts per 15 minutes per IP\n  message: {\n    error: 'Too many payment attempts. Please wait 15 minutes before trying again.',\n    resetTime: new Date(Date.now() + 15 * 60 * 1000)\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\n// Package definitions for Phase 4\nconst PACKAGES = {\n  basic: {\n    id: 'basic',\n    name: 'Basic Package',\n    price: 299, // $2.99 in cents\n    originalPrice: 599,\n    features: [\n      'All generated names',\n      'Basic brandability analysis',\n      'Copy and export functionality',\n      'Domain suggestions',\n      'Email support'\n    ],\n    nameLimit: 50,\n    exportFormats: ['csv'],\n    domainChecking: false,\n    priority: 'standard'\n  },\n  premium: {\n    id: 'premium',\n    name: 'Premium Package',\n    price: 999, // $9.99 in cents\n    originalPrice: 1999,\n    features: [\n      'All generated names + bonus variations',\n      'Advanced brandability analysis',\n      'Domain checking and availability',\n      'PDF export with branding guide',\n      'Priority customer support',\n      'Trademark screening guidance'\n    ],\n    nameLimit: 100,\n    exportFormats: ['csv', 'pdf'],\n    domainChecking: true,\n    priority: 'high'\n  },\n  enterprise: {\n    id: 'enterprise',\n    name: 'Enterprise Package',\n    price: 2999, // $29.99 in cents\n    originalPrice: 5999,\n    features: [\n      'Everything in Premium',\n      'Custom logo concepts',\n      'Trademark screening guidance',\n      'White-label rights',\n      'Dedicated account manager',\n      'Custom branding consultation'\n    ],\n    nameLimit: 200,\n    exportFormats: ['csv', 'pdf', 'json'],\n    domainChecking: true,\n    priority: 'enterprise'\n  }\n};\n\n// Input validation for payment creation\nconst validatePaymentRequest = [\n  body('sessionId')\n    .notEmpty()\n    .withMessage('Session ID is required'),\n  body('packageId')\n    .isIn(Object.keys(PACKAGES))\n    .withMessage('Invalid package selection'),\n  body('customerEmail')\n    .isEmail()\n    .normalizeEmail()\n    .withMessage('Valid email address required'),\n  body('customerName')\n    .optional()\n    .isLength({ min: 2, max: 100 })\n    .withMessage('Customer name must be 2-100 characters')\n];\n\n// POST /api/payments/create-checkout - Create Stripe checkout session\nrouter.post('/create-checkout', paymentLimiter, validatePaymentRequest, async (req, res, next) => {\n  try {\n    // Validate request\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid payment request',\n        errors: errors.array()\n      });\n    }\n\n    const {\n      sessionId,\n      packageId,\n      customerEmail,\n      customerName = 'Startup Founder',\n      successUrl = `${process.env.FRONTEND_URL}/results/${sessionId}?payment=success`,\n      cancelUrl = `${process.env.FRONTEND_URL}/results/${sessionId}?payment=cancelled`\n    } = req.body;\n\n    // Validate package exists\n    const selectedPackage = PACKAGES[packageId];\n    if (!selectedPackage) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid package selection'\n      });\n    }\n\n    // Verify session exists and is valid\n    const session = await getNamingSession(sessionId);\n    if (!session) {\n      return res.status(404).json({\n        success: false,\n        message: 'Session not found or expired'\n      });\n    }\n\n    // Check if session already has a payment\n    const existingPayment = await getSessionPayment(sessionId);\n    if (existingPayment && existingPayment.status === 'completed') {\n      return res.status(400).json({\n        success: false,\n        message: 'Session already has a completed payment'\n      });\n    }\n\n    logger.info('Creating checkout session:', {\n      sessionId,\n      packageId,\n      customerEmail,\n      price: selectedPackage.price,\n      ip: req.ip\n    });\n\n    // Create Stripe checkout session\n    const checkoutSession = await paymentService.createCheckoutSession({\n      priceData: {\n        currency: 'usd',\n        productData: {\n          name: selectedPackage.name,\n          description: `StartupNamer.org ${selectedPackage.name} - AI-Generated Startup Names`,\n          images: [`${process.env.FRONTEND_URL}/images/package-${packageId}.png`]\n        },\n        unitAmount: selectedPackage.price\n      },\n      quantity: 1,\n      customerEmail,\n      metadata: {\n        sessionId: sessionId.toString(),\n        packageId,\n        customerName,\n        originalPrice: selectedPackage.originalPrice.toString(),\n        discount: (selectedPackage.originalPrice - selectedPackage.price).toString()\n      },\n      successUrl,\n      cancelUrl\n    });\n\n    // Store payment intent in database\n    const paymentRecord = await createPaymentRecord({\n      sessionId,\n      packageId,\n      stripeCheckoutId: checkoutSession.id,\n      customerEmail,\n      customerName,\n      amount: selectedPackage.price,\n      originalAmount: selectedPackage.originalPrice,\n      status: 'pending'\n    });\n\n    res.status(200).json({\n      success: true,\n      message: 'Checkout session created successfully',\n      data: {\n        checkoutUrl: checkoutSession.url,\n        checkoutSessionId: checkoutSession.id,\n        paymentId: paymentRecord.id,\n        package: selectedPackage,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours\n      }\n    });\n\n  } catch (error) {\n    logger.error('Checkout creation failed:', error);\n    next(new AppError('Failed to create checkout session', 500));\n  }\n});\n\n// POST /api/payments/webhook - Stripe webhook handler\nrouter.post('/webhook', express.raw({ type: 'application/json' }), async (req, res, next) => {\n  try {\n    const sig = req.headers['stripe-signature'];\n    const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n    let event;\n    try {\n      event = paymentService.constructWebhookEvent(req.body, sig, endpointSecret);\n    } catch (err) {\n      logger.error('Webhook signature verification failed:', err.message);\n      return res.status(400).send(`Webhook Error: ${err.message}`);\n    }\n\n    logger.info('Processing webhook event:', {\n      type: event.type,\n      id: event.id\n    });\n\n    // Handle the event\n    switch (event.type) {\n      case 'checkout.session.completed':\n        await handleCheckoutCompleted(event.data.object);\n        break;\n      case 'payment_intent.succeeded':\n        await handlePaymentSucceeded(event.data.object);\n        break;\n      case 'payment_intent.payment_failed':\n        await handlePaymentFailed(event.data.object);\n        break;\n      default:\n        logger.info('Unhandled webhook event type:', event.type);\n    }\n\n    res.status(200).json({ received: true });\n\n  } catch (error) {\n    logger.error('Webhook processing failed:', error);\n    next(new AppError('Webhook processing failed', 500));\n  }\n});\n\n// GET /api/payments/session/:sessionId - Get payment status for session\nrouter.get('/session/:sessionId', async (req, res, next) => {\n  try {\n    const { sessionId } = req.params;\n\n    if (!sessionId || !/^\\d+$/.test(sessionId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid session ID'\n      });\n    }\n\n    const payment = await getSessionPayment(sessionId);\n    \n    if (!payment) {\n      return res.status(404).json({\n        success: false,\n        message: 'No payment found for this session'\n      });\n    }\n\n    const packageInfo = PACKAGES[payment.package_id] || null;\n\n    res.status(200).json({\n      success: true,\n      data: {\n        payment: {\n          id: payment.id,\n          status: payment.status,\n          packageId: payment.package_id,\n          amount: payment.amount,\n          originalAmount: payment.original_amount,\n          customerEmail: payment.customer_email,\n          createdAt: payment.created_at,\n          completedAt: payment.completed_at\n        },\n        package: packageInfo,\n        features: packageInfo ? packageInfo.features : [],\n        isPremium: payment.status === 'completed'\n      }\n    });\n\n  } catch (error) {\n    logger.error('Payment status retrieval failed:', error);\n    next(new AppError('Failed to retrieve payment status', 500));\n  }\n});\n\n// POST /api/payments/upgrade-session - Upgrade existing session\nrouter.post('/upgrade-session', paymentLimiter, validatePaymentRequest, async (req, res, next) => {\n  try {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Invalid upgrade request',\n        errors: errors.array()\n      });\n    }\n\n    const { sessionId, packageId, customerEmail, customerName } = req.body;\n\n    // Check if session already has premium access\n    const existingPayment = await getSessionPayment(sessionId);\n    if (existingPayment && existingPayment.status === 'completed') {\n      return res.status(400).json({\n        success: false,\n        message: 'Session already has premium access'\n      });\n    }\n\n    // Upgrade session to premium\n    await upgradeSessionToPremium(sessionId, packageId);\n\n    // Create checkout session (same as regular payment)\n    const checkoutResponse = await createCheckoutSession({\n      sessionId,\n      packageId,\n      customerEmail,\n      customerName\n    });\n\n    res.status(200).json({\n      success: true,\n      message: 'Session upgrade initiated',\n      data: checkoutResponse\n    });\n\n  } catch (error) {\n    logger.error('Session upgrade failed:', error);\n    next(new AppError('Failed to upgrade session', 500));\n  }\n});\n\n// GET /api/payments/packages - Get available packages\nrouter.get('/packages', async (req, res, next) => {\n  try {\n    res.status(200).json({\n      success: true,\n      data: {\n        packages: PACKAGES,\n        currency: 'USD',\n        discountPercentage: 50,\n        promotionEnds: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days\n      }\n    });\n  } catch (error) {\n    logger.error('Package retrieval failed:', error);\n    next(new AppError('Failed to retrieve packages', 500));\n  }\n});\n\n// Helper functions\nasync function getNamingSession(sessionId) {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(\n      'SELECT * FROM naming_sessions WHERE id = $1 AND created_at > NOW() - INTERVAL \\'7 days\\'',\n      [sessionId]\n    );\n    return result.rows[0] || null;\n  } finally {\n    client.release();\n  }\n}\n\nasync function getSessionPayment(sessionId) {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(\n      'SELECT * FROM payments WHERE session_id = $1 ORDER BY created_at DESC LIMIT 1',\n      [sessionId]\n    );\n    return result.rows[0] || null;\n  } finally {\n    client.release();\n  }\n}\n\nasync function createPaymentRecord(data) {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(\n      `INSERT INTO payments (session_id, package_id, stripe_checkout_id, customer_email, customer_name, amount, original_amount, status)\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`,\n      [\n        data.sessionId,\n        data.packageId,\n        data.stripeCheckoutId,\n        data.customerEmail,\n        data.customerName,\n        data.amount,\n        data.originalAmount,\n        data.status\n      ]\n    );\n    return result.rows[0];\n  } finally {\n    client.release();\n  }\n}\n\nasync function updatePaymentStatus(checkoutSessionId, status, metadata = {}) {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(\n      `UPDATE payments \n       SET status = $1, completed_at = CASE WHEN $1 = 'completed' THEN NOW() ELSE completed_at END,\n           stripe_payment_intent_id = $3, metadata = $4\n       WHERE stripe_checkout_id = $2 RETURNING *`,\n      [status, checkoutSessionId, metadata.paymentIntentId, JSON.stringify(metadata)]\n    );\n    return result.rows[0];\n  } finally {\n    client.release();\n  }\n}\n\nasync function upgradeSessionToPremium(sessionId, packageId) {\n  const client = await pool.connect();\n  try {\n    await client.query(\n      'UPDATE naming_sessions SET premium_package = $1, upgraded_at = NOW() WHERE id = $2',\n      [packageId, sessionId]\n    );\n  } finally {\n    client.release();\n  }\n}\n\n// Webhook event handlers\nasync function handleCheckoutCompleted(checkoutSession) {\n  try {\n    logger.info('Processing checkout completion:', {\n      checkoutSessionId: checkoutSession.id,\n      paymentStatus: checkoutSession.payment_status\n    });\n\n    if (checkoutSession.payment_status === 'paid') {\n      const payment = await updatePaymentStatus(checkoutSession.id, 'completed', {\n        paymentIntentId: checkoutSession.payment_intent,\n        customerEmail: checkoutSession.customer_details?.email,\n        amountTotal: checkoutSession.amount_total\n      });\n\n      if (payment) {\n        // Upgrade the naming session to premium\n        await upgradeSessionToPremium(payment.session_id, payment.package_id);\n        \n        // Send confirmation email (if email service is configured)\n        try {\n          await sendPaymentConfirmationEmail(payment);\n        } catch (emailError) {\n          logger.warn('Failed to send confirmation email:', emailError.message);\n        }\n\n        logger.info('Payment completed successfully:', {\n          paymentId: payment.id,\n          sessionId: payment.session_id,\n          packageId: payment.package_id\n        });\n      }\n    }\n  } catch (error) {\n    logger.error('Failed to handle checkout completion:', error);\n    throw error;\n  }\n}\n\nasync function handlePaymentSucceeded(paymentIntent) {\n  try {\n    logger.info('Payment succeeded:', {\n      paymentIntentId: paymentIntent.id,\n      amount: paymentIntent.amount\n    });\n\n    // Additional payment success handling if needed\n  } catch (error) {\n    logger.error('Failed to handle payment success:', error);\n    throw error;\n  }\n}\n\nasync function handlePaymentFailed(paymentIntent) {\n  try {\n    logger.info('Payment failed:', {\n      paymentIntentId: paymentIntent.id,\n      lastPaymentError: paymentIntent.last_payment_error\n    });\n\n    // Update payment status to failed\n    // Note: We'd need to find the payment by payment_intent_id\n    // This would require additional database schema changes\n  } catch (error) {\n    logger.error('Failed to handle payment failure:', error);\n    throw error;\n  }\n}\n\nasync function sendPaymentConfirmationEmail(payment) {\n  // Email service integration would go here\n  // For now, just log the action\n  logger.info('Payment confirmation email would be sent:', {\n    customerEmail: payment.customer_email,\n    packageId: payment.package_id,\n    amount: payment.amount\n  });\n}\n\nmodule.exports = router;"